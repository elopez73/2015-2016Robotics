#pragma config(Sensor, in4,    Battery,        sensorAnalog)
#pragma config(Sensor, dgtl1,  RightDriveEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  LeftDriveEncoder, sensorNone)
#pragma config(Sensor, dgtl4,  Piston2,        sensorDigitalOut)
#pragma config(Sensor, dgtl5,  LeftArmEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  RightArmEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  Claws,          sensorDigitalOut)
#pragma config(Sensor, dgtl10, Piston1,        sensorDigitalOut)
#pragma config(Sensor, dgtl11, LeftDriveEncoder, sensorQuadEncoder)
#pragma config(Motor,  port1,           Leftintake,    tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           FrontRightDrive, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           FrontLeftDrive, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           RightArmB,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           LeftArmB,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           LeftArmT,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           RightArmT,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           BackLeftDrive, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           BackRightDrive, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          Rightintake,   tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;

float Bat1Read = nImmediateBatteryLevel/1000.0;  // this is a variable set up to store the value of battery 1
float Bat2Read = SensorValue[Battery]/280.00;  // this is a variable set up to store the value of battery 2 (use an analog sensor port set to analog as the sensor)
float BackupBatteryRead = BackupBatteryLevel/1000.0;  // this is a variable set up to store the value of back up battery
string Bat1Value, Bat2Value, backupBattery;  // these are variables used when formating each voltage

int RSpd =0;
int LSpd =0;
int Strf =0;
int StallPower = 10;  // Value to set motors to when not in use (clutch)
int ArmUp = 3000;     // Highest point the arm can reach
int ArmDown = 100; // Lowest point the arm can reach
int count = 0;
int atonomous = 0;
int count2 = 0;
int Reset = 1210;
int Escape;


float PID_KpDrive =0.1;
float PID_KpDriveL = 0.1;
float PID_KpDriveR = 0.1;
float PID_KdDrive = 0.1;
float PID_KdDriveL = 0.1;
float PID_KdDriveR = 0.1;

float PID_KpArm   = 1.5;
float PID_KpArmL  = 1.5;
float PID_KpArmR  = 1.5;

float PID_KiArm   = 0.5;
float PID_KiArmL  = 0.05;
float PID_KiArmR  = 0.5;

float PID_KdArm   = 1.0;
float PID_KdArmL  = 1.5;
float PID_KdArmR  = 1.5;


static float PIDRequestedValueDrive;
static float PIDRequestedValueDriveLeft;
static float PIDRequestedValueDriveRight;
static float PIDRequestedValueArm;
static float PIDRequestedValueArmL;
static float PIDRequestedValueArmR;
static float PIDRequestedValueOpenClaw;

int togle = 0;

// PID Control //
/////////////////////////////////////////////
/////////////////////////////////////////////
/////////////////////////////////////////////

task PIDDriveF ()
{
	float PIDErrorL;
	float PIDErrorR;
	float PIDLastErrorL;
	float PIDLastErrorR;
	float PIDCurrentSensorValueL;
	float PIDCurrentSensorValueR;
	float PIDDriveL;
	float PIDDriveR;
	float PIDDerivativeL;
	float PIDDerivativeR;

	SensorValue[RightDriveEncoder]  = 0;
	SensorValue[LeftDriveEncoder]  = 0;

	PIDLastErrorL  = 0;
	PIDLastErrorR  = 0;

	while(true)
	{
		PIDCurrentSensorValueL  =  SensorValue[LeftDriveEncoder];
		PIDCurrentSensorValueR  = -SensorValue[RightDriveEncoder];

		//Proportional Part
		PIDErrorL  = PIDCurrentSensorValueL  - PIDRequestedValueDrive;
		PIDErrorR  = PIDCurrentSensorValueR  - PIDRequestedValueDrive;

		//Derivative Part
		PIDDerivativeL  = PIDErrorL  - PIDLastErrorL;
		PIDLastErrorL   = PIDErrorL;
		PIDDerivativeR  = PIDErrorR  - PIDLastErrorR;
		PIDLastErrorR   = PIDErrorR;

		//Calculating the motor speed
		PIDDriveL  = (PID_KpDrive * PIDErrorL)  + (PID_KdDrive * PIDLastErrorL);
		PIDDriveR  = (PID_KpDrive * PIDErrorR)  + (PID_KdDrive * PIDLastErrorR);

		motor[FrontLeftDrive]  = -PIDDriveL;
		motor[BackLeftDrive] = -PIDDriveL;
		motor[FrontRightDrive]  =  PIDDriveR;

		motor[BackRightDrive] =  PIDDriveR;
	}
}

task PIDLeftDrive()
{
	float PIDErrorL;
	float PIDLastErrorL;
	float PIDCurrentSensorValueL;
	float PIDDriveL;
	float PIDDerivativeL;

	SensorValue[LeftDriveEncoder]  = 0;

	PIDLastErrorL  = 0;

	while(true)
	{
		PIDCurrentSensorValueL  = SensorValue[LeftDriveEncoder];

		//Proportional Part
		PIDErrorL  = PIDCurrentSensorValueL  - PIDRequestedValueDriveLeft;

		//Derivative Part
		PIDDerivativeL = PIDErrorL - PIDLastErrorL;
		PIDLastErrorL  = PIDErrorL;

		//Calculating the motor speed
		PIDDriveL  = (PID_KpDriveL * PIDErrorL)  + (PID_KdDriveL *PIDLastErrorL);

		motor[FrontLeftDrive]  = -PIDDriveL;
		motor[BackLeftDrive] = -PIDDriveL;
	}
}

task PID_Right()
{
	float PIDErrorR;
	float PIDLastErrorR;
	float PIDCurrentSensorValueR;
	float PIDDriveR;
	float PIDDerivativeR;

	SensorValue[RightDriveEncoder]  = 0;

	PIDLastErrorR  = 0;

	while(true)
	{
		pidCurrentSensorValueR  = -SensorValue[RightDriveEncoder];

		//Proportional Part
		PIDErrorR  = PIDCurrentSensorValueR  - PIDRequestedValueDriveRight;

		//Derivative Part
		PIDDerivativeR = PIDErrorR - PIDLastErrorR;
		PIDLastErrorR  = PIDErrorR;

		//Calculating the motor speed
		PIDDriveR  = (PID_KpDriveR * PIDErrorR)  + (PID_KdDriveR * PIDLastErrorR);

		motor[FrontRightDrive]  = -PIDDriveR;
		motor[BackLeftDrive] = -PIDDriveR;
	}
}
void clutchDriveLeft()
{
	motor[FrontLeftDrive] = 5;
	motor[FrontRightDrive] = -5;
	motor[BackLeftDrive] = 5;
	motor[BackRightDrive] = -5;
	wait1Msec(100);
	stopAllMotors();
}

void clutchDriveRight()
{
	motor[FrontLeftDrive] = -5;
	motor[FrontRightDrive] = 5;
	motor[BackLeftDrive] = -5;
	motor[BackRightDrive] = 5;
	wait1Msec(100);
	stopAllMotors();
}

task intakeClutch()
{

motor[Leftintake] = 15;
motor[Rightintake] =15;
}

task clutchdown()
{
	motor[LeftArmT] = -15;
	motor[LeftArmB] = -15;
	motor[RightArmT] = -15;
	motor[RightArmB] = -15;
}

task clutch()
{
	motor[LeftArmT] = 25;
	motor[LeftArmB] = 25;
	motor[RightArmT] = 25;
	motor[RightArmB] = 25;
}
void Jult()
{
	motor[FrontLeftDrive] = 127;
	motor[FrontRightDrive] = 127;
	wait1Msec(300);
	motor[FrontLeftDrive] = 0;
	motor[FrontRightDrive] = 0;
}

// BASIC VOID MOVEMENTS //
//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////

void Intake( int Spd, int Dis )
{

	motor[Leftintake]=Spd;
	motor[Rightintake]=Spd;

	wait1Msec(Dis);

	motor[Leftintake]= 0;
	motor[Rightintake]= 0;
}
//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
void Outtake(int Spd, int Dis)
{

	motor[Leftintake]=-Spd;
	motor[Rightintake]=-Spd;

	wait1Msec(Dis);

	motor[Leftintake]= 0;
	motor[Rightintake]= 0;
}
//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
void DriveForward(int Spd, int Dis)
{

	SensorValue[LeftDriveEncoder] = 0;
	SensorValue[RightDriveEncoder] = 0;

	while((SensorValue[RightDriveEncoder] + SensorValue[LeftDriveEncoder]) /2 < Dis)
	{
		motor[FrontLeftDrive] = Spd;
		motor[BackLeftDrive] = Spd;
		motor[FrontRightDrive] = Spd;
		motor[BackRightDrive] =Spd;
	}
	motor[FrontLeftDrive] = 0;
	motor[BackLeftDrive] = 0;
	motor[FrontRightDrive] = 0;
	motor[BackRightDrive] = 0;

}
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
void DriveBack(int Spd, int Dis)
{

	SensorValue[LeftDriveEncoder] = 0;
	SensorValue[RightDriveEncoder] = 0;

	while(( abs( SensorValue[RightDriveEncoder]) +  abs (SensorValue[LeftDriveEncoder])) /2 < Dis)
	{
		motor[FrontLeftDrive] = -Spd;
		motor[BackLeftDrive] = -Spd;
		motor[FrontRightDrive] = -Spd;
		motor[BackRightDrive] =-Spd;
	}
	motor[FrontLeftDrive] = 0;
	motor[BackLeftDrive] = 0;
	motor[FrontRightDrive] = 0;
	motor[BackRightDrive] = 0;
}
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
void rightTurn(int Spd, int Dis)
{
	SensorValue[LeftDriveEncoder] = 0;
	SensorValue[RightDriveEncoder] = 0;
	while (( abs(SensorValue[RightDriveEncoder]) + abs(SensorValue[LeftDriveEncoder])) /2 < Dis)
	{
		motor[FrontLeftDrive] = Spd;
		motor[BackLeftDrive] = Spd;
		motor[FrontRightDrive] = -Spd;
		motor[BackRightDrive] =-Spd;
	}

	motor[FrontLeftDrive] = 0;
	motor[BackLeftDrive] = 0;
	motor[FrontRightDrive] = 0;
	motor[BackRightDrive] = 0;
}
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////
void leftTurn( int Spd, int Dis)
{
	SensorValue[LeftDriveEncoder] = 0;

	SensorValue[RightDriveEncoder] = 0;

	while ((  abs(SensorValue[RightDriveEncoder]) + abs(SensorValue[LeftDriveEncoder])) /2 < Dis)
	{
		motor[FrontLeftDrive] = -Spd;
		motor[BackLeftDrive] = -Spd;
		motor[FrontRightDrive] = Spd;
		motor[BackRightDrive] =Spd;
	}
	motor[FrontLeftDrive] = 0;
	motor[BackLeftDrive] = 0;
	motor[FrontRightDrive] = 0;
	motor[BackRightDrive] = 0;
}
//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
void ArmLift( int Spd, int Dis)
{
	SensorValue[LeftArmEncoder] = 0;
	SensorValue[RightArmEncoder] = 0;

	stopTask(clutch);
	while((abs(SensorValue[LeftArmEncoder])+ abs(SensorValue[RightArmEncoder]))/2 < Dis)
	{
		motor[LeftArmT] =Spd;
		motor[LeftArmB] = Spd;
		motor[RightArmT] = Spd;
		motor[RightArmB] = Spd;
	}

	motor[LeftArmT] = 0;
	motor[LeftArmB] = 0;
	motor[RightArmT] = 0;
	motor[RightArmB] = 0;

	startTask(clutch);
}
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
void ArmLower( int Spd, int Dis)
{
	SensorValue[LeftArmEncoder] = 0;
	SensorValue[RightArmEncoder] = 0;

	stopTask(clutch);
	while((abs(SensorValue[LeftArmEncoder]) + abs(SensorValue[RightArmEncoder]))/2 < Dis)
	{
		motor[LeftArmT] = -Spd;
		motor[LeftArmB] = -Spd;
		motor[RightArmT] = -Spd;
		motor[RightArmB] = -Spd;
	}

	motor[LeftArmT] = 0;
	motor[LeftArmB] = 0;
	motor[RightArmT] = 0;
	motor[RightArmB] = 0;

	startTask(clutch);
}

// ADVANCED VOID MOVEMENTS//
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////


// ALL DRIVE FORWARD MOVEMENTS //
//////////////////////////////////////////////////
//////////////////////////////////////////////////
void DriveForwardIntake(int Spd, int Dis, int intakeSpd,int intakeDis)
{
	SensorValue[LeftDriveEncoder] = 0;
	SensorValue[RightDriveEncoder] = 0;

	while((abs(SensorValue[RightDriveEncoder]) +abs(SensorValue[LeftDriveEncoder])) / 2 < Dis )
	{
		motor[FrontLeftDrive] = Spd;
		motor[BackLeftDrive] = Spd;
		motor[FrontRightDrive] = Spd;
		motor[BackRightDrive] =Spd;

		motor[Leftintake]=intakeSpd;
		motor[Rightintake]=intakeSpd;

		wait1Msec(intakeDis);
	}
	motor[FrontLeftDrive] = 0;
	motor[BackLeftDrive] = 0;
	motor[FrontRightDrive] = 0;
	motor[BackRightDrive] = 0;

	motor[Leftintake]= 0;
	motor[Rightintake]= 0;
}
//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
void DriveForwardArmLift(int Spd, int Dis, int ArmDis, int ArmSpd)
{
	SensorValue[LeftDriveEncoder] = 0;
	SensorValue[RightDriveEncoder] = 0;
	SensorValue[LeftArmEncoder] = 0;
	SensorValue[RightArmEncoder] = 0;
	while((SensorValue[RightDriveEncoder] + SensorValue[LeftDriveEncoder]) /2 < Dis && SensorValue[LeftArmEncoder] + SensorValue[RightArmEncoder]/2 < ArmDis )
	{
		motor[FrontLeftDrive] = Spd;
		motor[BackLeftDrive] = Spd;
		motor[FrontRightDrive] = Spd;
		motor[BackRightDrive] =Spd;

		motor[LeftArmT] = ArmSpd;
		motor[LeftArmB] = ArmSpd;
		motor[RightArmT] = ArmSpd;
		motor[RightArmB] = ArmSpd;
	}
	motor[FrontLeftDrive] = 0;
	motor[BackLeftDrive] = 0;
	motor[FrontRightDrive] = 0;
	motor[BackRightDrive] = 0;

	motor[LeftArmT] = 0;
	motor[LeftArmB] = 0;
	motor[RightArmT] = 0;
	motor[RightArmB] = 0;
	startTask(clutch);
}
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
void DriveForwardArmLower(int Spd, int Dis, int ArmDis, int ArmSpd)
{
	SensorValue[LeftDriveEncoder] = 0;
	SensorValue[RightDriveEncoder] = 0;
	SensorValue[LeftArmEncoder] = 0;
	SensorValue[RightArmEncoder] = 0;
	while((SensorValue[RightDriveEncoder] + SensorValue[LeftDriveEncoder]) /2 < Dis && SensorValue[LeftArmEncoder] + SensorValue[RightArmEncoder]/2 > -ArmDis )
	{
		motor[FrontLeftDrive] = Spd;
		motor[BackLeftDrive] = Spd;
		motor[FrontRightDrive] = Spd;
		motor[BackRightDrive] =Spd;
		motor[LeftArmT] = -ArmSpd;
		motor[LeftArmB] = -ArmSpd;
		motor[RightArmT] = -ArmSpd;
		motor[RightArmB] = -ArmSpd;
	}
	motor[FrontLeftDrive] = 0;
	motor[BackLeftDrive] = 0;
	motor[FrontRightDrive] = 0;
	motor[BackRightDrive] = 0;

	motor[LeftArmT] = 0;
	motor[LeftArmB] = 0;
	motor[RightArmT] = 0;
	motor[RightArmB] = 0;
	startTask(clutch);
}
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////



// ALL DRIVE BACK MOVEMENTS//
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////

void DriveBackArmLower(int Spd, int Dis, int ArmDis, int ArmSpd)
{
	SensorValue[LeftDriveEncoder] = 0;
	SensorValue[RightDriveEncoder] = 0;
	SensorValue[LeftArmEncoder] = 0;
	SensorValue[RightArmEncoder] = 0;
	while(( abs(SensorValue[RightDriveEncoder]) + abs(SensorValue[LeftDriveEncoder])) /2 < Dis || (SensorValue[LeftArmEncoder] + SensorValue[RightArmEncoder])/2 > ArmDis )
	{
		if ((abs(SensorValue[RightDriveEncoder]) + abs(SensorValue[LeftDriveEncoder])) /2 > Dis)
		{
			motor[FrontLeftDrive] = 0;
			motor[BackLeftDrive] = 0;
			motor[FrontRightDrive] = 0;
			motor[BackRightDrive] =0;

			motor[LeftArmT] = -ArmSpd;
			motor[LeftArmB] = -ArmSpd;
			motor[RightArmT] = -ArmSpd;
			motor[RightArmB] = -ArmSpd;
		}
		else if(((SensorValue[LeftArmEncoder]) + (SensorValue[RightArmEncoder]))/2 < ArmDis )
		{
			motor[LeftArmT] = 0;
			motor[LeftArmB] = 0;
			motor[RightArmT] = 0;
			motor[RightArmB] = 0;

			motor[FrontLeftDrive] = -Spd;
			motor[BackLeftDrive] = -Spd;
			motor[FrontRightDrive] = -Spd;
			motor[BackRightDrive] =-Spd;
		}
		else
		{
			motor[FrontLeftDrive] = -Spd;
			motor[BackLeftDrive] = -Spd;
			motor[FrontRightDrive] = -Spd;
			motor[BackRightDrive] =-Spd;

			motor[LeftArmT] = ArmSpd;
			motor[LeftArmB] = ArmSpd;
			motor[RightArmT] = ArmSpd;
			motor[RightArmB] = ArmSpd;
		}
	}
	motor[FrontLeftDrive] = 0;
	motor[BackLeftDrive] = 0;
	motor[FrontRightDrive] = 0;
	motor[BackRightDrive] = 0;

	motor[LeftArmT] = 0;
	motor[LeftArmB] = 0;
	motor[RightArmT] = 0;
	motor[RightArmB] = 0;
	startTask(clutch);
}
//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
void DriveBackArmLift(int Spd, int Dis, int ArmDis,int ArmSpd)
{

	SensorValue[LeftDriveEncoder] = 0;
	SensorValue[RightDriveEncoder] = 0;
	SensorValue[LeftArmEncoder] = 0;
	SensorValue[RightArmEncoder] = 0;
	while(( abs(SensorValue[RightDriveEncoder]) + abs(SensorValue[LeftDriveEncoder])) /2 < Dis || (SensorValue[LeftArmEncoder] + SensorValue[RightArmEncoder])/2 < ArmDis )
	{
		if ((abs(SensorValue[RightDriveEncoder]) + abs(SensorValue[LeftDriveEncoder])) /2 > Dis)
		{
			motor[FrontLeftDrive] = 0;
			motor[BackLeftDrive] = 0;
			motor[FrontRightDrive] = 0;
			motor[BackRightDrive] =0;

			motor[LeftArmT] = ArmSpd;
			motor[LeftArmB] = ArmSpd;
			motor[RightArmT] = ArmSpd;
			motor[RightArmB] = ArmSpd;
		}
		else if(((SensorValue[LeftArmEncoder]) + (SensorValue[RightArmEncoder]))/2 > ArmDis )
		{
			motor[LeftArmT] = 0;
			motor[LeftArmB] = 0;
			motor[RightArmT] = 0;
			motor[RightArmB] = 0;

			motor[FrontLeftDrive] = -Spd;
			motor[BackLeftDrive] = -Spd;
			motor[FrontRightDrive] = -Spd;
			motor[BackRightDrive] =-Spd;
		}
		else
		{
			motor[FrontLeftDrive] = -Spd;
			motor[BackLeftDrive] = -Spd;
			motor[FrontRightDrive] = -Spd;
			motor[BackRightDrive] =-Spd;

			motor[LeftArmT] = ArmSpd;
			motor[LeftArmB] = ArmSpd;
			motor[RightArmT] = ArmSpd;
			motor[RightArmB] = ArmSpd;
		}
	}
	motor[FrontLeftDrive] = 0;
	motor[BackLeftDrive] = 0;
	motor[FrontRightDrive] = 0;
	motor[BackRightDrive] = 0;

	motor[LeftArmT] = 0;
	motor[LeftArmB] = 0;
	motor[RightArmT] = 0;
	motor[RightArmB] = 0;
	startTask(clutch);
}
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



// ALL RIGHT TURN MOVEMENTS//
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
void RightTurnArmLift( int Spd, int Dis, int ArmDis, int ArmSpd)
{
	SensorValue[LeftDriveEncoder] = 0;
	SensorValue[RightDriveEncoder] = 0;
	SensorValue[LeftArmEncoder] = 0;
	SensorValue[RightArmEncoder] = 0;
	while (( abs(SensorValue[RightDriveEncoder]) + abs(SensorValue[LeftDriveEncoder]))  / 2 < Dis ||( abs(SensorValue[LeftArmEncoder]) +abs(SensorValue[RightArmEncoder]))/2 < ArmDis)
	{
		if ((abs(SensorValue[RightDriveEncoder]) + abs(SensorValue[LeftDriveEncoder])) /2 > Dis)
		{

			motor[FrontLeftDrive] = 0;
			motor[BackLeftDrive] = 0;
			motor[FrontRightDrive] = 0;
			motor[BackRightDrive] =0;

			motor[LeftArmT] = ArmSpd;
			motor[LeftArmB] = ArmSpd;
			motor[RightArmT] = ArmSpd;
			motor[RightArmB] = ArmSpd;
		}
		else if (( abs(SensorValue[LeftArmEncoder]) +abs(SensorValue[RightArmEncoder]))/2 > ArmDis)
		{
			motor[LeftArmT] = 0;
			motor[LeftArmB] = 0;
			motor[RightArmT] = 0;
			motor[RightArmB] = 0;
			startTask(clutch);
			motor[FrontLeftDrive] = Spd;
			motor[BackLeftDrive] = Spd;
			motor[FrontRightDrive] = -Spd;
			motor[BackRightDrive] = -Spd;
		}
		else
		{
			motor[FrontLeftDrive] = Spd;
			motor[BackLeftDrive] = Spd;
			motor[FrontRightDrive] = -Spd;
			motor[BackRightDrive] = -Spd;
			startTask(clutch);
			motor[LeftArmT] = ArmSpd;
			motor[LeftArmB] = ArmSpd;
			motor[RightArmT] = ArmSpd;
			motor[RightArmB] = ArmSpd;
		}
		motor[LeftArmT] = 0;
		motor[LeftArmB] = 0;
		motor[RightArmT] = 0;
		motor[RightArmB] = 0;
		startTask(clutch);
		motor[FrontLeftDrive] = 0;
		motor[BackLeftDrive] = 0;
		motor[FrontRightDrive] = 0;
		motor[BackRightDrive] = 0;



	}
}
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////

// ALL LEFT TURN MOVEMENTS//
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////
void LeftTurnArmLower ( int Spd, int Dis, int ArmDis, int ArmSpd)
{
	SensorValue[LeftDriveEncoder] = 0;
	SensorValue[RightDriveEncoder] = 0;
	SensorValue[LeftArmEncoder] = 0;
	SensorValue[RightArmEncoder] = 0;
	while((SensorValue[RightDriveEncoder] + SensorValue[LeftDriveEncoder]) /2 < Dis || (SensorValue[LeftArmEncoder] + SensorValue[RightArmEncoder])/2 > ArmDis )
	{
		if ((SensorValue[RightDriveEncoder] + SensorValue[LeftDriveEncoder]) /2 > Dis)
		{
			motor[FrontLeftDrive] = 0;
			motor[BackLeftDrive] = 0;
			motor[FrontRightDrive] = 0;
			motor[BackRightDrive] =0;

			motor[LeftArmT] = -ArmSpd;
			motor[LeftArmB] = -ArmSpd;
			motor[RightArmT] = -ArmSpd;
			motor[RightArmB] = -ArmSpd;
		}
		else if((SensorValue[LeftArmEncoder] + SensorValue[RightArmEncoder])/2 < ArmDis )
		{
			motor[LeftArmT] = 0;
			motor[LeftArmB] = 0;
			motor[RightArmT] = 0;
			motor[RightArmB] = 0;

			motor[FrontLeftDrive] = -Spd;
			motor[BackLeftDrive] = -Spd;
			motor[FrontRightDrive] = Spd;
			motor[BackRightDrive] =Spd;
		}
		else
		{
			motor[FrontLeftDrive] = -Spd;
			motor[BackLeftDrive] = -Spd;
			motor[FrontRightDrive] = Spd;
			motor[BackRightDrive] =Spd;

			motor[LeftArmT] = -ArmSpd;
			motor[LeftArmB] = -ArmSpd;
			motor[RightArmT] = -ArmSpd;
			motor[RightArmB] = -ArmSpd;
		}
		motor[LeftArmT] = 0;
		motor[LeftArmB] = 0;
		motor[RightArmT] = 0;
		motor[RightArmB] = 0;
		startTask(clutch);
		motor[FrontLeftDrive] = 0;
		motor[BackLeftDrive] = 0;
		motor[FrontRightDrive] = 0;
		motor[BackRightDrive] = 0;
	}
}
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
void LeftTurnArmLift ( int Spd, int Dis, int ArmDis, int ArmSpd)
{
	SensorValue[LeftDriveEncoder] = 0;
	SensorValue[RightDriveEncoder] = 0;
	SensorValue[LeftArmEncoder] = 0;
	SensorValue[RightArmEncoder] = 0;
	while((SensorValue[RightDriveEncoder] + SensorValue[LeftDriveEncoder]) /2 < Dis || (SensorValue[LeftArmEncoder] + SensorValue[RightArmEncoder])/2 < ArmDis )
	{
		if ((SensorValue[RightDriveEncoder] + SensorValue[LeftDriveEncoder]) /2 > Dis)
		{
			motor[FrontLeftDrive] = 0;
			motor[BackLeftDrive] = 0;
			motor[FrontRightDrive] = 0;
			motor[BackRightDrive] =0;

			motor[LeftArmT] = ArmSpd;
			motor[LeftArmB] = ArmSpd;
			motor[RightArmT] = ArmSpd;
			motor[RightArmB] = ArmSpd;
		}
		else if((SensorValue[LeftArmEncoder] + SensorValue[RightArmEncoder])/2 > ArmDis )
		{
			motor[LeftArmT] = 0;
			motor[LeftArmB] = 0;
			motor[RightArmT] = 0;
			motor[RightArmB] = 0;

			motor[FrontLeftDrive] = -Spd;
			motor[BackLeftDrive] = -Spd;
			motor[FrontRightDrive] = Spd;
			motor[BackRightDrive] =Spd;
		}
		else
		{
			motor[FrontLeftDrive] = -Spd;
			motor[BackLeftDrive] = -Spd;
			motor[FrontRightDrive] = Spd;
			motor[BackRightDrive] =Spd;

			motor[LeftArmT] = ArmSpd;
			motor[LeftArmB] = ArmSpd;
			motor[RightArmT] = ArmSpd;
			motor[RightArmB] = ArmSpd;
		}
		motor[LeftArmT] = 0;
		motor[LeftArmB] = 0;
		motor[RightArmT] = 0;
		motor[RightArmB] = 0;
		startTask(clutch);
		motor[FrontLeftDrive] = 0;
		motor[BackLeftDrive] = 0;
		motor[FrontRightDrive] = 0;
		motor[BackRightDrive] = 0;
	}
}
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////


// ALL EXTRA VOIDS//
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////


void RightDrive(int Spd, int Dis)
{
	SensorValue[RightDriveEncoder] = 0;

	while (abs(SensorValue[RightDriveEncoder]) < Dis)
	{
		motor[FrontRightDrive]=Spd;
		motor[BackRightDrive]=Spd;
	}
	motor[FrontRightDrive]=0;
	motor[BackRightDrive]=0;
}
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
void Leftdrive(int Spd, int Dis)
{
	SensorValue[LeftDriveEncoder]=0;

	while(abs(SensorValue[LeftDriveEncoder]) < Dis)
	{
		motor[FrontLeftDrive]=Spd;
		motor[BackLeftDrive]=Spd;
	}
	motor[FrontLeftDrive]=0;
	motor[BackLeftDrive]=0;

}
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////
void LowerandIntake ( int Spd, int Dis, int intakeSpd, int intakeDis)
{
	SensorValue[LeftArmEncoder] = 0;
	SensorValue[RightArmEncoder] = 0;
	int val = 0;  //  creaat counter variable
	stopTask(clutch);
	while((SensorValue[LeftArmEncoder] + SensorValue[RightArmEncoder])/2 < Dis || val < intakeDis)  // arm is less than hight or intake is less than time
	{
		if((SensorValue[LeftArmEncoder] + SensorValue[RightArmEncoder])/2 > Dis)  // if arm reaches hight, then turn off arm motors, but keep intake running
		{
			motor[LeftArmT] = 0;  // turn off arm
			motor[LeftArmB] = 0;
			motor[RightArmT] = 0;
			motor[RightArmB] = 0;

			motor[Leftintake] = intakeSpd;  // run intake still
			motor[Rightintake] = intakeSpd;
		}
		else if(val > intakeDis)  // if intake reaches time, then turn off intake motors, but keep arm motors running
		{
			motor[Leftintake] = 0;
			motor[Rightintake] = 0;  // turn off intake

			motor[LeftArmT] = -Spd;  // keep arm motors running
			motor[LeftArmB] = -Spd;
			motor[RightArmT] = -Spd;
			motor[RightArmB] = -Spd;
		}
		else
		{
			motor[LeftArmT] = -Spd;
			motor[LeftArmB] = -Spd;
			motor[RightArmT] = -Spd;
			motor[RightArmB] = -Spd;

			motor[Leftintake] = intakeSpd;
			motor[Rightintake] = intakeSpd;
		}
		wait1Msec(1);
		val++;  // add one to the timer
	}
	motor[Leftintake] = 0;
	motor[Rightintake] = 0;

	motor[LeftArmT] = 0;
	motor[LeftArmB] = 0;
	motor[RightArmT] = 0;
	motor[RightArmB] = 0;

	startTask(clutch);
}
//////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
void Higherandouttake ( int Spd, int Dis, int intakeSpd, int intakeDis)
{
	SensorValue[LeftArmEncoder] = 0;
	SensorValue[RightArmEncoder] = 0;
	int val = 0;  //  creaat counter variable
	stopTask(clutch);
	while((SensorValue[LeftArmEncoder] + SensorValue[RightArmEncoder])/2 > Dis || val < intakeDis)  // arm is less than hight or intake is less than time
	{
		if((SensorValue[RightArmEncoder] + SensorValue[RightArmEncoder])/2 < Dis)  // if arm reaches hight, then turn off arm motors, but keep intake running
		{
			motor[LeftArmT] = 0;  // turn off arm
			motor[LeftArmB] = 0;
			motor[RightArmT] = 0;
			motor[RightArmB] = 0;

			motor[Leftintake] = -intakeSpd;  // run intake still
			motor[Rightintake] = -intakeSpd;
		}
		else if(val > intakeDis)  // if intake reaches time, then turn off intake motors, but keep arm motors running
		{
			motor[Leftintake] = 0;
			motor[Rightintake] = 0;  // turn off intake

			motor[LeftArmT] = Spd;  // keep arm motors running
			motor[LeftArmB] = Spd;
			motor[RightArmT] = Spd;
			motor[RightArmB] = Spd;
		}
		else
		{
			motor[LeftArmT] = Spd;
			motor[LeftArmB] = Spd;
			motor[RightArmT] = Spd;
			motor[RightArmB] = Spd;

			motor[Leftintake] = -intakeSpd;
			motor[Rightintake] = -intakeSpd;
		}
		wait1Msec(1);
		val++;  // add one to the timer
	}
	motor[Leftintake] = 0;
	motor[Rightintake] = 0;

	motor[LeftArmT] = 0;
	motor[LeftArmB] = 0;
	motor[RightArmT] = 0;
	motor[RightArmB] = 0;

	startTask(clutch);
}
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
// END OF ALL VOID MOVEMENTS//



// LCD SCREEN//
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

//Clear LCD-------------------------------------------------------
void clear()
{
	clearLCDLine(0);
	clearLCDLine(1);
}
//----------------------------------------------------------------

//Top Three Numbers-----------------------------------------------
void bottomThreeNumbers()
{
	displayLCDPos(1, 2);
	displayNextLCDString("1");
	displayLCDPos(1, 6);
	displayNextLCDString("Back");
	displayLCDPos(1, 14);
	displayNextLCDString("2");
}
void LCD ()
{
	if(count == 0)
	{
		clear();
		displayLCDCenteredString(0, "Which Side?");
		displayLCDPos(1, 1);
		displayNextLCDString("Red");
		displayLCDPos(1, 12);
		displayNextLCDString("Blue");
		waitForPress();
		if(nLCDButtons == leftButton)

		{
			waitForRelease();
			count = 1;
		}
		else if(nLCDButtons == rightButton)
		{
			waitForRelease();
			count = 8;
		}
	}
	else if(count == 1)
	{
		clear();
		displayLCDCenteredString(0, "Which Red Spot?");
		displayLCDPos(1, 0);
		displayNextLCDString("Skyrise");
		displayLCDPos(1, 12);
		displayNextLCDString("Post");
		waitForPress();
		if(nLCDButtons == leftButton)
		{
			waitForRelease();
			count = 2;
		}
		else if(nLCDButtons == rightButton)
		{
			waitForRelease();
			count = 5;
		}
		else if(nLCDButtons == centerButton)
		{
			waitForRelease();
			count = 0;
		}
	}
	else if(count == 2)
	{
		clear();
		displayLCDCenteredString(0, "Red Skyrise:");
		bottomThreeNumbers();
		waitForPress();\
		if(nLCDButtons == leftButton)
		{
			waitForRelease();
			count = 3;
			atonomous = 1;
		}
		else if(nLCDButtons == centerButton)
		{
			waitForRelease();
			count = 0;
		}
		else if(nLCDButtons == rightButton)
		{
			waitForRelease();
			count = 4;
			atonomous = 2;
		}
	}
	else if(count == 5)
	{
		clear();
		displayLCDCenteredString(0, "Red Post:");
		bottomThreeNumbers();
		waitForPress();
		if(nLCDButtons == leftButton)
		{
			waitForRelease();
			count = 6;
			atonomous = 3;
		}
		else if(nLCDButtons == centerButton)
		{
			waitForRelease();
			count = 0;
		}
		else if(nLCDButtons == rightButton)
		{
			waitForRelease();
			count = 7;
			atonomous = 4;
		}
	}
	else if(count == 8)
	{
		displayLCDCenteredString(0, "Which Blue Spot?");
		displayLCDPos(1, 0);
		displayNextLCDString("Skyrise");
		displayLCDPos(1, 12);
		displayNextLCDString("Post");
		waitForPress();
		if(nLCDButtons == leftButton)
		{
			waitForRelease();
			count = 9;
		}
		else if(nLCDButtons == rightButton)
		{
			waitForRelease();
			count = 12;
		}
		else if(nLCDButtons == centerButton)
		{
			waitForRelease();
			count = 0;
		}
	}
	else if(count == 9)
	{
		clear();
		displayLCDCenteredString(0, "Blue Skyrise:");
		bottomThreeNumbers();
		waitForPress();
		if(nLCDButtons == leftButton)
		{
			waitForRelease();
			count = 10;
			atonomous = 5;
		}
		else if(nLCDButtons == centerButton)
		{
			waitForRelease();
			count = 0;
		}
		else if(nLCDButtons == rightButton)
		{
			waitForRelease();
			count = 11;
			atonomous = 6;
		}
	}
	else if(count == 12)
	{
		clear();
		displayLCDCenteredString(0, "Blue Post:");
		bottomThreeNumbers();
		waitForPress();
		if(nLCDButtons == leftButton)
		{
			waitForRelease();
			count = 13;
			atonomous = 7;
		}
		else if(nLCDButtons == centerButton)
		{
			waitForRelease();
			count = 0;
		}
		else if(nLCDButtons == rightButton)
		{
			waitForRelease();
			count = 14;
			atonomous = 8;
		}
	}
}
//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////



// PID Code //
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////





// DRIVER CONTROL//
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
task liftControl()
{
	while(true)
	{
		if (vexRT[Ch3Xmtr2] > 2 || vexRT [ Ch3Xmtr2] < -2 )
		{
			motor[LeftArmT] = vexRT[Ch3Xmtr2];
			motor[LeftArmB] = vexRT[Ch3Xmtr2];
			motor[RightArmT] = vexRT[Ch3Xmtr2];
			motor[RightArmB] = vexRT[Ch3Xmtr2];
		}
		else
		{
			motor[LeftArmT] = 0; // Controller lift, left stick
			motor[LeftArmB] = 0;
			motor[RightArmT] = 0;
			motor[RightArmB] = 0;
		}
	}
}
task driverControl()
{
	while(true)
	{
		motor[FrontRightDrive] =  vexRT[Ch2];
		motor[BackRightDrive] =  vexRT[Ch2];
		motor[FrontLeftDrive] = vexRT[Ch3];
		motor[BackLeftDrive] =  vexRT[Ch3];
	}
}

task Assist()
{
	while(true)
	{if( vexRT[Btn5U] == 1)
		{
			SensorValue[Piston1] = 1;
			SensorValue[Piston2] = 1;
		}
		else
		{

			SensorValue[Piston1] = 0;
			SensorValue[Piston2] = 0;
		}
	}
}
//task HalfSpd()
//{
//	while(true)
//	{
//		if(vexRT[Btn6U] == 1)
//		{
//			togle = togle+1;
//		}
//		wait1Msec(200);
//	}
//}

//task HalfSpeed2()
//{
//	if(togle % 0)
//	{
//		motor[FrontRightDrive] =  vexRT[Ch2]/2;
//		motor[BackRightDrive] =  vexRT[Ch2]/2;
//		motor[FrontLeftDrive] = vexRT[Ch3]/2;
//		motor[BackLeftDrive] =  vexRT[Ch3]/2;
//	}
//	else if(togle % 0)
//	{
//		motor[FrontRightDrive] =  vexRT[Ch2];
//		motor[BackRightDrive] =  vexRT[Ch2];
//		motor[FrontLeftDrive] = vexRT[Ch3];
//		motor[BackLeftDrive] =  vexRT[Ch3];

//	}
//}


task HalfSpd()
{
	while (true)
	{
		if (vexRT[Btn6U]==1)
		{
			motor[FrontRightDrive] =  vexRT[Ch2]/2;
			motor[BackRightDrive] =  vexRT[Ch2]/2;
			motor[FrontLeftDrive] = vexRT[Ch3]/2;
			motor[BackLeftDrive] =  vexRT[Ch3]/2;
		}
		else
		{
			motor[FrontRightDrive] =  vexRT[Ch2];
			motor[BackRightDrive] =  vexRT[Ch2];
			motor[FrontLeftDrive] = vexRT[Ch3];
			motor[BackLeftDrive] =  vexRT[Ch3];
		}

	}
}
task clawControl()
{
	int toggle = 0;
	while(true)
	{
		if(vexRT[Btn6UXmtr2] == 1)
		{
			if(toggle == 0)
			{
				toggle = 1;
				while(vexRT[Btn6UXmtr2] == 1)
				{
					SensorValue[Claws] = toggle;
				}
			}
			else if(toggle == 1)
			{
				toggle = 0;
				while(vexRT[Btn6UXmtr2] == 1)
				{
					SensorValue[Claws] = toggle;
				}
			}
		}
	}
}
task intake()
{
	while(true)
	{
		motor[Leftintake] = vexRT [Ch2Xmtr2];
		motor[Rightintake] = vexRT [Ch2Xmtr2];
	}
}








//task intake()
//{
//	while(true)
//	{
//		if (vexRT[Btn5DXmtr2]==1)  // if intake pressed
//		{
//			motor[Leftintake] = 127;
//			motor[Rightintake] = 127;
//		}
//		else if (vexRT[Btn5UXmtr2]==1)  // if outake pressed
//		{
//			motor[Leftintake] = -127;
//			motor[Rightintake] = -127;
//		}
//		else if(vexRT[Btn5U]==1)
//		{
//			motor[Leftintake] = -50;
//			motor[Rightintake] = -50;
//		}
//		else
//		{
//			motor[Leftintake] = 0;
//			motor[Rightintake] = 0;
//		}
//	}
//}

void ButtonCommands()
{

	if(nLCDButtons == 1 || vexRT[Btn8R])  // if first LCD button is pressed display battery voltages
	{
		clear();
		bLCDBacklight = true; // Turn on LCD Backlight

		displayLCDString(0, 0, "Bat1 Bat2 Backup"); // Display names of each value on line 0

		sprintf(Bat1Value, "%1.2f%c", Bat1Read); // Format incoming value to new value "Bat1Value" and put in string
		displayLCDString(1, 0, Bat1Value);  // display "Bat1Value" on line 1 at position 0

		sprintf(Bat2Value, "%1.2f%c", Bat2Read); // Format incoming value to new value "Bat2Value" and put in string
		displayLCDString(1, 5, Bat2Value); // display "Bat2Value" on line 1 at position 5

		sprintf(backupBattery, "%1.2f%c", BackupBatteryRead); // Format incoming value to new value "backupBattery" and put in string
		displayLCDString(1, 10, backupBattery); // display "backupBattery" on line 1 at position 10
	}
	else  // if LCD button is not pressed
	{
		bLCDBacklight = true; // Turn off LCD Backlight
		// clear both LCD lines
		clearLCDLine(0);
		clearLCDLine(1);
		// Display default message
		displayLCDCenteredString(0, "NHRC 569D");
		displayLCDCenteredString(1, "Skyrise Comp");
	}
}

// GAME AUTONOMOUS VOIDS//
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////
void RedS1()
{
	ArmLift(63,20);
	startTask(clutchdown);
	wait1Msec(800);
	//ArmLower(40,2);
	//	wait1Msec(400);4
	SensorValue(Claws)= 0;
	wait1Msec(500);
	stopTask(clutchdown);
	ArmLift(127,48);
	wait1Msec(500);
	DriveBack(63.5,55);
	leftTurn(60,85);
	clutchDriveLeft();
	DriveForward(50,8);
	ArmLower(63.5,76);
	startTask(clutchdown);
	wait1Msec(500);
	SensorValue(Claws) = 1;
	DriveBack(100,15);
	leftTurn(59,67);
	clutchDriveLeft();
	Intake(127,230);
	DriveForward(60,115);
	stopTask(clutchdown);
	ArmLift(127,10);
	DriveBackArmLift(90,20,100,127);
	rightTurn(60,100);
	clutchDriveRight();
	DriveForward(50,50);
	Outtake(127,300);
	DriveBack(50,50);
	//rightTurn(50,105);
	//clutchDriveRight();
	//DriveForward(50,50);
	////ArmLower(63.5,10);
	//DriveForward(50,20);
	//wait1Msec(500);
	//SensorValue(Claws) = 0;
	//wait1Msec(500);
	//ArmLift(127,48);
	//wait1Msec(500);
	//DriveBack(63.5,35);
	//leftTurn(60,90);
	//clutchDriveLeft();
	//DriveBack(50,6);
	//ArmLower(63.5,50);
	//wait1Msec(500);
	//SensorValue(Claws) = 1;
	//DriveBack(100,15);
	//Leftdrive(70,10);
	//RightTurnArmLift(70,30,10,127);



}
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
void RedS2()
{

}
////////////////////////////////////////////////////
////////////////////////////////////////////////////
void RedP1()
{
	ArmLift(127,90);
	ArmLower(63.5,90);
	Intake(127,300);
	DriveForward(127,115);
	DriveForwardIntake(127,550,121,900);
	//DriveForwardIntake(115,280,127,300);
	//Intake(127,300);
	leftTurn(90,130);
	DriveForward(60,350);
	DriveBackArmLift(127,50,300,127);
	rightTurn(70,70);
	DriveForward(60,150);

	Outtake(120,200);

	DriveBack(60,70);
	rightTurn(60,150);
	Outtake(127,400);
	rightTurn(70,150);
	DriveForward(60,100);
	Outtake(127,400);




}
////////////////////////////////////////////////////
////////////////////////////////////////////////////
void RedP2()
{
	ArmLift(127,120);
	ArmLower(63.5,120);
	Intake(127,300);
	DriveForward(127,92);
	Intake(127,750);
	leftTurn(60,50);
	clutchDriveLeft();
	DriveForward(60,200);
	wait1Msec(200);
	leftTurn(60,166);
	clutchDriveLeft();
	DriveForward(127,118);
	Intake(127,950);
	//ArmLift(127,100);
	DriveForward(60,70);
	Intake(127,1000);
	DriveBackArmLift(60,60,360,127);
	startTask(clutch);
	Intake(127,200);
	startTask(intakeClutch);
	leftTurn(60,390);
clutchDriveLeft();
wait1Msec(100);
	DriveForward(60,255);
	wait1Msec(100);
	DriveBack(55,40);
	wait1Msec(100);
	stopTask(clutch);
	ArmLower(127,35);
	stopTask(intakeClutch);
	Outtake(127,1600);

	//Intake(127,600);
	//ArmLift(127,100);
	//DriveForward(60,72);
	//Intake(127,800);
	//DriveBack(60,6);
	//ArmLower(127,100);
	//Intake(127,600);
	//DriveBack(127,60);
}
////////////////////////////////////////////////////
////////////////////////////////////////////////////3
void BlueS1()
{
ArmLift(63,1);
	wait1Msec(800);
	//ArmLower(127,1);
	//	wait1Msec(400);4
	SensorValue(Claws)= 0;
	wait1Msec(500);
	ArmLift(127,48);
	wait1Msec(500);
	DriveBack(63.5,35);
	rightTurn(60,90);
	DriveBack(50,6);
	ArmLower(63.5,70);
	wait1Msec(500);
	SensorValue(Claws) = 1;
	DriveBack(100,15);
	//leftTurn(59,65);
	//Intake(127,250);
	//DriveForward(60,115);
	//ArmLift(127,10);
	//DriveBackArmLift(90,20,100,127);
	//rightTurn(60,100);
	//DriveForward(50,50);
	//Outtake(127,300);
	//DriveBack(50,50);
	leftTurn(50,105);
	DriveForward(50,50);
	//ArmLower(63.5,10);
	DriveForward(50,20);
	wait1Msec(500);
	SensorValue(Claws) = 0;
	wait1Msec(500);
	ArmLift(127,48);
	wait1Msec(500);
	DriveBack(63.5,35);
	rightTurn(60,90);
	DriveBack(50,6);
	ArmLower(63.5,50);
	wait1Msec(500);
	SensorValue(Claws) = 1;
	DriveBack(100,15);
	//Leftdrive(70,10);
	//RightTurnArmLift(70,30,10,127);

}
////////////////////////////////////////////////////
////////////////////////////////////////////////////
void BlueS2()
{

}
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
void BlueP1()
{
	ArmLift(127,90);
	ArmLower(63.5,90);
	Intake(127,300);
	DriveForward(127,115);
	DriveForwardIntake(127,550,121,900);
	//DriveForwardIntake(115,280,127,300);
	//Intake(127,300);
	rightTurn(90,130);
	DriveForward(60,350);
	DriveBackArmLift(127,50,300,127);
	leftTurn(70,70);
	DriveForward(60,150);

	Outtake(120,200);

	DriveBack(60,70);
	leftTurn(60,150);
	Outtake(127,400);
	leftTurn(70,150);
	DriveForward(60,100);
	Outtake(127,400);
}
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////

void BlueP2()
{

	ArmLift(127,120);
	ArmLower(63.5,122);
	startTask(clutchdown);
	Intake(127,300);
	DriveForward(127,82);
	Intake(127,800);
	rightTurn(60,50);
	clutchDriveRight();
	DriveForward(60,280);
	wait1Msec(200);
	rightTurn(60,70);
	clutchDriveRight();
	DriveForward(127,70);
	Intake(127,1000);
	//ArmLift(127,100);
	DriveForward(60,70);
	Intake(127,1000);
	stopTask(clutchdown);
	DriveBackArmLift(60,60,360,127);
	startTask(clutch);
	Intake(127,200);
	startTask(intakeClutch);
	rightTurn(60,335);
clutchDriveRight();
wait1Msec(200);
	DriveForward(60,310);
	wait1Msec(100);
	DriveBack(55,30);
	stopTask(clutch);
	ArmLower(127,45);
	stopTask(intakeClutch);
	Outtake(127,1600);

	//Intake(127,600);
	//ArmLift(127,100);
	//DriveForward(60,72);
	//Intake(127,800);
	//DriveBack(60,6);
	//ArmLower(127,100);
	//Intake(127,600);
	//DriveBack(127,60);
}
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
// END OF GAME VOIDS//






// PRE AUTON //
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	while(bIfiRobotDisabled)
	{
		if(atonomous != 0)
		{
			if(atonomous == 1)
			{
				clear();
				displayLCDCenteredString(0, "RedS1");
			}
			else if(atonomous == 2)
			{
				clear();
				displayLCDCenteredString(0, "RedS2");
			}
			else if(atonomous == 3)
			{
				clear();
				displayLCDCenteredString(0, "RedP1");
			}
			else if(atonomous == 4)
			{
				clear();
				displayLCDCenteredString(0, "RedP2");
			}
			else if(atonomous == 5)
			{
				clear();
				displayLCDCenteredString(0, "BlueS1");
			}
			else if(atonomous == 6)
			{
				clear();
				displayLCDCenteredString(0, "BlueS2");
			}
			else if(atonomous == 7)
			{
				clear();
				displayLCDCenteredString(0, "BlueP1");
			}
			else if(atonomous == 8)
			{
				clear();
				displayLCDCenteredString(0, "BlueP2");
			}
			else
			{
				clear();
				displayLCDCenteredString(0, "NONE");
			}
		}
		else
		{
			LCD();
		}
	} // while disabled
}  // void pre auto

task autonomous()
{
	if(atonomous == 1)
	{
		clear();
		displayLCDCenteredString(0, "RedS1 Enabled");
		RedS1();
	}

	else if(atonomous == 2)
	{
		clear();
		displayLCDCenteredString(0, "RedS2");
		RedS2();
	}
	else if(atonomous == 3)
	{
		clear();
		displayLCDCenteredString(0, "RedP1");
		RedP1();
	}
	else if(atonomous == 4)
	{
		clear();
		displayLCDCenteredString(0, "RedP2");
		RedP2();
	}

	else if(atonomous == 5)
	{
		clear();
		displayLCDCenteredString(0, "BlueS1");
		BlueS1();
	}
	else if(atonomous == 6)
	{
		clear();
		displayLCDCenteredString(0, "BlueS2");
		BlueS2();
	}
	else if(atonomous == 7)
	{
		clear();
		displayLCDCenteredString(0, "BlueP1");
		BlueP1();
	}
	else if(atonomous == 8)
	{
		clear();
		displayLCDCenteredString(0, "BlueP2");
		BlueP2();
	}
	else
	{
		clear();
		displayLCDCenteredString(0, "NONE");
	}
}

task usercontrol()
{
	startTask(clawControl);
	startTask(liftControl);
	startTask(intake);
	startTask(Assist);
	startTask(HalfSpd);
	while (true)
	{
		wait1Msec(1);
	}
}  // user control task main
